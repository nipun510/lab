
15th Feb 2022
- proxy 
    - lets you provid a substitute or placeholder for another object.
    - controls access to the original object. 
    - allows to perform something before or after the request goes through to the original object.
    - Uses:
        - lazy initialization
        - access control
        - remote service
        - logging proxy
        - caching proxy
        - smart reference
    - serviceInterface, service, proxy, client
    - eg : thirdPartyYoutubeInf,  thridPartyYoutubeClass, cachedYoutubeClass, youtubeManager

- flyweight
    - lets fit more objects into the available amount of RAM by sharing common parts of state i.e extrinsic state storage.
    - needed when a huge no of objects is required which barely fit in memory.
    - flyweight and immutability.
    - flyweightFactory, flyweight, context, client
    - eg: treeFactory, treeType, tree, forest


objects relation
  - association
  - composition
  - aggregation


- singleton:
    - ensures a class has only one instance
    - provides a global point of access to the instance.
    - multithreading handling
    - impl: ../cpp/singleton.cc

- builder:
    - lets you to construct complex objects step by step.
    - allows to produce different types and representation of an object using the same construction code.
    - Avoid ugly contructor calls or telescopic constructor.
    - builder interface, concrete builders, director construction methods.
    - example:
        - House construction

- factory method:
    - defines an interface for creating an object in a superclass 
    - but let the subclasses decide which concrete classes to instantiate.
    - dependency inversion principle.
    - creator, concreateCreators, product, concreteProducts.
    - example:
        - pizza store
    
- abstract factory:
    - lets you produce families of related objects without specifying their concrete classes.
    - abstract factory, concrete factories, products, concrete products.
    - client doesn't have to depend upon concrete instance of factories or products, ensures extensibility.
    - example:
        - GUI factory
        - furniture factory

- prototype
    - lets you copy existing objects without making your code dependent on their classes.
    - prototype, prototypeRegistry, clone method

- adapter
    - converts the interface of a class into another interface the client expect.
    - Targer<interface>, Adapter, Adaptee
    - Types
        - class Adapter
        - object Adapter

- bridge
    - use to vary not only your implementations but also you abstractions.
    - prevents geometric increase in number of subclasses by using composition instead of inheritance.
    - Remote,  Device

- composite:
    - lets you compose objects in tree structures and then work with these structures as if they were individual objects.
    - component, leaf, composite
    
- decorator 
    - attaches additional responsibilities to an object dynamically.
    - provides a flexible alternative to subclassing for extending functionality.
    - Component, ConcreteComponent, Decorator, concreteDectors 
    - Decorator derives from Component as well as compose component.
    - Example : Design bevarage with types HouseBlend, DarkRost, Decaf, Espresso and Condiment like milk, Mocha, Soy, Whip
                Design application to writeData with features like encryption, compression etc 


- facade 
    - provides a simplified interface to a library, a framework, or any other other complex set of classes.
    - application classes don't depend on  a billion classes provided by complex framework but just on facade.
    - provides simple interface to the wrapped set of classes.

SOLID_Principles:
  single responsibility principle:
    - a class should have just one reason to change.
    - eg: employee, timeSheetReport

  open/closed principle:
    - classes should be open for extension but closed for modification
    - A class shouldn't depend on concrete classes but on interface.
    - eg: strategy pattern.

  liskov substitution principle:
    - subclasses objects should be able to be passed in place of objects of super class without breaking the client code.
    - critical when developing libraries and frameworks.
    - points to consider for subclass:
       - parameter types and return types.
       - pre-conditions and post-conditions
       - exception
       - invariants of superclass
       - shouldn't change values of private fields of super class
    - eg: document, readOnlyDocument/writableDocument, project   

  interface segregation principle:
    - interfaces should be narrow enough that client classes don't have to implement behaviours they don't need.
    - eg: CloudProvider interface should be divided into CloudHostingProvider, CloudStorageProvider and CDNProvider interfaces.
      
  dependency inversion priciple:
    - depend upon abstraction, don't depend upon concrete classes.
    - high level classes shoudn't depend on low-level classes and vice-versa. Both should depend on abstractions.
    - eg: factory method pattern

Design_principles:
  - Encapsulate what varies
  - Favor composition over inheritance
      - can't reduce the interface of the superclass.
      - overriding methods must have compatible behavior with the base ones. see liskov substitution
      - breaks encapsulation of the superclass,  tight coupling.
      - can lead to creation of parallel inheritance hierarchies. For vehicles, cargoType * engineType * navigationType
