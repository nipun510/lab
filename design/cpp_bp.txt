- Define a constructor if a class has an invariant.
- A constructor should create a fully intialized object.
- If a constructor cannot construct a valid object, throw an exception
- Prefer default constructors to be simple and non throwing.    
- By default, declare single-argument constructor explicit.

- Prefer in-class intializers to member initializer in constructors for constant initializers.
- Prefer intitilization to assigment in constructor
- Use delegating constructors to represent common actions for all constructors of a class.
- Use inherting constructor to import constructor into a derived class that doesn't need further initialization.    

- copy operation should copy
    - after x = y, x == y holds true
    - value semantics
    - pointer semantics
- Ensure that a copyable class has a default constructor.
    - semiregular: default initializable and copyable
- for value-like type, consider providing a nonexcept swap function.    
- copy assignment or move assigment
    - non-virtual, return non-const &
    - safe for self-assignment, and associated cost
- A polymorphic class should suppress public copy/move and assignment
    - To avoid accidental slicing.
    - either delete them or make them protected.
- For making deep copies of polymorphic classes, prefer a virtual clone function instead of public copy constructor/assignment.    
    - covariant return type
- Don't call virtual functions in constructors and destructors.    
- Use a factory function if you need "virtual behaviour" during intialization.    
    - templated unquie_ptr, smart_ptr return type, static create, only in base
    - a protected token to prevent constructor to be called publicly.
- make == symmetric with respect to operand types and nonexcept.
    - applies to all the usual comparision operators !=, <, <=, > and >=
- Beware of == on base classes.   

- prefer concrete types over class hierarchies.
    - more simpler
    - allocation/deallocation overhead
    - runtime overhead to perform indirection
- make concrete types regular    
    - copyable
    - default initializable
    - equality comparable
- Don't make data members const or references
    - with the default functionality they prevent copy assignment and moving.
    - if you need a member to point to something use a pointer(raw or smart, and gsl::not_null 
      if it shouldn't be null) instread of a reference.
    - same behavior can be expressed with non-public non-const members wth const accessor member functions.
- Ensure all non-const data members have the same access level
- Use multiple inheritance to represent multiple distinct interfaces.
- Don't provide different default arguments for a virtual function and an overrider.

- Access polymorphic objects through pointers and references.    
- Use dynamic_cast where class navigation is unavoidable
- Prefer virtual functions to casting.

- A base class destructor should be either public and virtual or protected and non-virtual
